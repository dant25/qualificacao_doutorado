\chapter{Tema Secundário II : Particionamento de Modelos para geração Malha em paralelo}\label{tema2}


Todo desenvolvimento de um programa paralelo tem que passar por três fases que são: particionamento da entrada, agrupamento das partições e mapeamento dos agrupamentos. Estes conceitos partem da ideia que para um bom algoritmo paralelo executar, é preciso uma boa estratégia de divisão ou particionamento da entrada para ao final ser feita a junção das várias soluções.

Há ainda a preocupação com a distribuição das tarefas entre os processadores, levando em conta que, ao final, todos eles devam ter realizado uma quantidade similar de processamento, evitando que alguns processadores fiquem ociosos enquanto outros estão sobrecarregados. Se isto acontecer, significa que a carga foi devidamente balanceada entre os processadores. Para isto ocorrer é preciso que tenha sido realizado uma etapa de estimativa de trabalho computacional ou estimativa de carga.

Neste capítulo, são apresentados conceitos necessários para o entendimento de um particionamento de de modelos para geração de malha. Isso envolve saber o que é uma malha, como estimar o trabalho computacional ou carga que um modelo geraria para gerar a sua malha, realizar a decomposição ou particionamento de um modelo para a execução em paralelo e estratégias de balanceamento de carga entre processadores. Também será apresentado alguns trabalhos que fazem particionamento de modelos, dando ênfase no modo que é tratado o particionamento dos modelos de entrada e como foi feita a estimativa da carga.


\section{Conceitos e Definições}\label{Geometria computacional}

\subsection{Malhas Triangulares}

Existem diversos tipos de malhas, entre as mais conhecidas e utilizadas estão as malhas que utilizam triângulos. Por ser a menor estrutura geométrica que consegue representar modelos tando no espaço bidimensional como no tridimensional, as  malhas triangulares (Figura \ref{fig:malhas_triangulares}) se tornaram as mais utilizadas nas pesquisas da área de Geometria Computacional. Nos casos tridimensionais estas malhas são chamadas de malhas tetraédricas.

 \begin{figure}[htbp]
 	\centering
 	\includegraphics[width=1.0\textwidth]{fig/malha_bi_tri.png}
 	\caption{Exemplo duas malhas triangulares, uma bidimensional e outra tridimensional.} 
 	\label{fig:malhas_triangulares}
 \end{figure}

Triangulações ou tetraedralizações são muitas vezes chamadas de malhas ou usadas como malhas, como no caso do método dos elementos finitos (MEF), já que malha é uma união de elementos, que podem ser triângulos, por exemplo. Pode-se definir uma malha $M$ de uma maneira genérica como:

\begin{itemize}
 \item $\varOmega = \bigcup\limits_{k \in M} k $, onde $\varOmega$ é um domínio finito limitado,
 \item O interior de cada elemento $k$ em $M$ é não vazio,
 \item A interseção do interior de dois elementos de $M$ é vazia.
\end{itemize}


Uma triangulação também é uma malha, mas nem toda malha é uma triangulação (Figura \ref{fig:malha_invalida}). Uma tetraedralização deve respeitar as mesmas regras de uma triangulação, logo uma tetraedralização também é uma malha válida. Neste trabalho quando for mencionado malha, será sempre a malha que respeita as mesmas propriedades de uma triangulação. A definição de triangulação segundo \cite{bib:Triangulations_applications} diz que:

\begin{itemize}
  \item Nenhum triângulo pertencente à triangulação pode ter pontos colineares.
  \item A interseção do interior de quaisquer dois triângulos pertencentes à triangulação é vazia.
  \item As bordas de 2 triângulos quaisquer só podem fazer interseção com vértices ou arestas.
  \item A união de todos os triângulos da triangulação é igual ao domínio.  
  \item O domínio deve ser conectado.
  \item Não deve existir buracos na triangulação, a menos que eles sejam definidos como entrada.
  \item Se um triângulo está na borda da triangulação então ele faz interseção por aresta no máximo dois triângulos.
\end{itemize}


 \begin{figure}[htbp]
 	\centering
 	\includegraphics[width=0.3\textwidth]{fig/malha_invalida.png}
 	\caption{Exemplo de malhas uma bidimensional que não é uma triangulação válida.} 
 	\label{fig:malha_invalida}
 \end{figure}


Existem malhas de diferentes geometrias e dimensões. Caso a topologia de elementos e vértices da malha siga alguma regra simples de indexação, essa malha será definida como estruturada, caso contrário, ela será classificada como não-estruturada. Nas malhas estruturadas o conhecimento dos vizinhos de cada elemento não depende do armazenamento ou existência desta informação. Já nas não-estruturadas, para se ter conhecimento dos vizinhos, é necessário armazenar ou calcular estas informações. Existem ainda as malhas mistas, que combinam malhas estruturadas e não-estruturadas (Figura \ref{fig:est_e_n_est}).

As malhas também podem ser classificadas de acordo com a geometria dos seus elementos, já que não são necessariamente formadas somente de triângulos.. Para malhas bidimensionais, por exemplo, elas podem ser de elementos triangulares ou quadrilaterais, por exemplo, como mostra a Figura \ref{fig:est_e_n_est}.

 \begin{figure}[htbp]
     \centering
     \includegraphics[width=0.5\textwidth]{fig/est_e_n_est.png}
     \caption{Exemplo de malha quadrilateral estruturada e não-estruturada triangular.} 
     \label{fig:est_e_n_est}
 \end{figure}
 
Para muitas aplicações, a qualidade dos elementos da malha é muito importante. Para classificar um elemento de uma malha triangular como bom ou ruim pode-se utilizar, dentre outras, uma métrica que é definida como $ \alpha = 2R_i / R_c $, onde $R_i$ e $R_c$ são os raios dos círculos inscrito e circunscrito, respectivamente. 
 
Esta métrica $\alpha$ tem valor $1,0$ para um triângulo equilátero. Quanto pior a qualidade do elemento, mais próximo de $0,0$ é o valor de $\alpha$. Pode-se dizer que os elementos com $\alpha \leq 0,1$ são de péssima qualidade e que os elementos com $\alpha \geq 0,7$ são de boa qualidade, como mostra a Figura \ref{fig:qualidade_elemento}.

 \begin{figure}[htbp]
     \centering
     \includegraphics[width=0.5\textwidth]{fig/qualidade_elemento.png}
     \caption{Exemplo de um elemento triangular de boa qualidade (esquerda) e dois de péssima qualidade (direita).} 
     \label{fig:qualidade_elemento}
 \end{figure}

\subsection{Geração de Malha}\label{Geração de Malha}

Nesta seção, são apresentadas as técnicas de geração de malhas triangulares mais conhecidas atualmente. Existem diversos algoritmos para geração de malhas, porém eles podem ser enquadrados uma das categorias a seguir:

\begin{itemize}
  \item Avanço de fronteira, técnica em que a malha é gerada a partir da borda da região;

  \item Delaunay, técnica em que a malha é gerada procurando-se maximizar o menor ângulo dos triângulos gerados para um dado conjunto de pontos;

  \item Arbitrária, técnica em que a malha é gerada de maneira diferente das anteriores.
\end{itemize}

\subsubsection{Avanço de Fronteira}

Este é um dos métodos mais populares de geração de malhas e consiste em criar os elementos no interior do domínio progressivamente a partir de um contorno, especificando a região a ser preenchida (Figura~\ref{fig:AF}a). Este contorno é chamado de fronteira inicial ou borda. Os elementos são gerados a partir dessa fronteira dada como entrada. Uma fronteira bidimensional é formada por um conjunto de arestas.

À medida que o algoritmo progride, a fronteira avança em direção ao interior, sempre removendo ou adicionando elementos de fronteira até que todo o domínio seja preenchido. O algoritmo chega ao fim quando não há mais fronteira, ou seja, o domínio foi totalmente triangularizado. 

Há casos em que o algoritmo não consegue mais gerar elementos para uma determinada fronteira, isso indica que o algoritmo falhou. O caso de falha ocorre quando todos os possíveis elementos a serem criados se sobrepõem a um elemento já existente. Por isso, é importante verificar se elementos se interceptam. Os casos de falha geralmente acontecem em modelos tridimensionais. Entretanto, já existem técnicas para contornar esses problemas e gerar malhas em modelos que falhariam.

Para gerar os novos triângulos no interior do domínio, é necessário criar novos pontos que não pertencem aos dados de entrada. Em geral, são utilizados os pontos de Steiner para isso \cite{bib:Ruppert99}.

Um algoritmo de avanço de fronteira procede da seguinte maneira no caso 2D (Figura~\ref{fig:AF}):
 
 \begin{enumerate}
\item{ Selecione uma aresta da fronteira, a aresta base (fig.~\ref{fig:AF}b);}
\item{ Encontre um ponto ideal para a formação de um novo triângulo com a aresta base (fig.~\ref{fig:AF}c);}
\item{ Crie uma região de busca em torno desse ponto ideal (fig.~\ref{fig:AF}d);}
\item{ Selecione o ponto dentro dessa região de busca cujo triângulo (entre esse ponto e a aresta base) seja válido e seja o de melhor qualidade, que pode ser um novo ponto ou um ponto já pertencente à malha;}
\item{ Forme o novo triângulo com o ponto selecionado e adicione-o à malha (fig.~\ref{fig:AF}e);}
\item{ Atualize a fronteira, inserindo as arestas que foram criadas e removendo as arestas que já existiam;}
\item{ Se existir aresta na fronteira, volte para o passo 1.}
\end{enumerate}

 \begin{figure}[htbp]
     \centering
     \includegraphics[width=1\textwidth]{fig/AF.jpg}
     \caption{Avanço de fronteira \cite{bib:Freitas10}.} 
     \label{fig:AF}
 \end{figure}

Pelo fato da fronteira ser sempre respeitada, os algoritmos de avanço de fronteira têm facilidade em tratar regiões descontínuas, ou por conterem buracos, ou por serem regiões separadas. Como os elementos mais próximos da borda são gerados primeiro, em geral, eles têm uma boa qualidade. A boa qualidade da malha gerada provê estabilidade e precisão à aplicação de métodos numéricos (como os métodos dos elementos finitos).

Porém, nem sempre todos os elementos gerados têm boa qualidade. Ao contrário dos elementos mais próximos da borda, os elementos mais internos à malha nem sempre têm boa qualidade devido à região tornar-se menor à medida que a fronteira avança. Geralmente uma técnica de suavização ou otimização é aplicada na malha resultante do algoritmo para tratar esses casos.

\subsubsection{Delaunay}

Esta é uma técnica bastante conhecida na área de geração de malhas, cujo nome é uma homenagem ao matemático russo Boris Delaunay. A entrada para esse problema é um conjunto de pontos e, geralmente, não são utilizados os pontos de Steiner para formar os triângulos.

O critério de Delaunay para a formação dos triângulos é que não exista nenhum outro ponto dentro do círculo que passa pelos três pontos desse triângulo (seu circuncírculo), critério este também chamado de "esfera vazia" (o circuncírculo desse triângulo, Figura~\ref{fig:criterio_delaunay}). O critério de Delaunay em si não se constitui num método de geração de malhas, mas é uma forma de saber onde os pontos devem estar localizados no espaço.

 \begin{figure}[htbp]
     \centering
     \includegraphics[width=0.65\textwidth]{fig/criterio_delaunay.jpg}
     \caption{a) Critério de Delaunay falhando para os dois triângulos. b) Triangulação válida respeitando o critério de Delaunay.} 
     \label{fig:criterio_delaunay}
 \end{figure}

A malha gerada por Delaunay visa maximizar os ângulos internos dos triângulos gerados, ou seja, dada uma aresta da triangulação de Delaunay, o ponto que forma o maior ângulo com essa aresta é o ponto que formará um triângulo de Delaunay com ela.

Existem algumas variações de algoritmos de Delaunay. Em uma delas, encontra-se uma aresta que faz parte da triangulação que é, em geral, uma aresta pertencente ao fecho convexo. A partir dela, é encontrado o ponto que formará um triângulo de Delaunay. Assim, com as novas arestas, encontram-se novos triângulos, em um algoritmo parecido com o de avanço de fronteira. Uma outra variação é feita a partir de inserção de pontos. A entrada é uma malha triangular não necessariamente de Delaunay e se modifica essa malha (de apenas um subconjunto de pontos da entrada) pré-existente (Figura~\ref{fig:triangulacao_insercao}).

\begin{figure}[htbp]
     \centering
     \includegraphics[width=1\textwidth]{fig/triangulacao_insercao.jpg}
     \caption{Triangulação por inserção de pontos \cite{bib:Freitas10}.} 
     \label{fig:triangulacao_insercao}
 \end{figure}

 Dependendo da disposição dos pontos da entrada, a triangulação final pode não ter boa qualidade, principalmente em regiões críticas, próximas à borda, gerando instabilidade em métodos numéricos. Uma alternativa para melhorar essa malha é fazer refinamentos e otimizações, que fazem uso de pontos de Steiner.

\subsubsection{Arbitrária}

As técnicas de geração de malha arbitrárias são aquelas que não se enquadram nem como Avanço de Fronteira e nem como Delaunay. As malhas são geradas em geral por algoritmos de varredura ou algum outro método.

Outro uso que essas malhas possuem é nas demonstrações de teoremas. O problema de ordenação de pontos pode ser reduzido ao problema de geração de malhas bidimensionais \cite{bib:Carvalho91}. Prova-se por redução que pode ser gerada uma malha triangular a partir do fecho convexo de um conjunto de pontos em duas dimensões numa complexidade na ordem de $O (n \log n)$.



\subsection{Estrutura de Dados}\label{Estrutura de dados}

Diversas estruturas de dados que foram criadas na área da computação são muito usadas em problemas de computação gráfica. No contexto desse trabalho, essas estruturas têm o objetivo de fazer uma decomposição espacial do domínio. Com essas decomposições, diversos cálculos são otimizados fazendo uma busca em qual parte da decomposição o objeto de interesse está e limitando os cálculos apenas aos elementos que pertencem a essa decomposição.

Essas estruturas são utilizadas em diversas aplicações como tratamento de colisão e renderização (Figura \ref{fig:ex_decomposicao}). Entre as estruturas de dados bidimensionais, as mais importantes são a \textit{quadtree}, \textit{octree} e a \textit{binary space partitioning} ou simplesmente BSP.

 \begin{figure}[htbp]
     \centering
     \includegraphics[width=0.7\textwidth]{fig/ex_decomposicao.jpg}
     \caption{Exemplo de uma decomposição espacial feita para renderização e teste de colisão. Fonte: http://togeskov.net/} 
     \label{fig:ex_decomposicao}
 \end{figure}

\subsubsection{\textit{Quadtree}}

Uma \textit{quadtree} é uma estrutura de dados baseada em árvore em que cada nó possui exatamente quatro filhos (Figura \ref{fig:quadtree_tree}). Em geral \textit{quadtrees} são utilizadas para decompor domínios bidimensionais recursivamente em quatro regiões de mesmo tamanho. As \textit{quadtrees} podem ser classificadas de acordo com o tipo do dado que elas representam (regiões, pontos, arestas, polígonos), isso vai depender do tipo de aplicação para o qual ele está sendo utilizada. Essa classificação altera o critério de subdivisão da \textit{quadtree}, por exemplo, o critério pode ser a quantidade de pontos internos há um quadrante da \textit{quadtree}, com isto é garantido a quantidade máxima de pontos internos a cada célula desta \textit{quadtree}.

 \begin{figure}[htbp]
     \centering
     \includegraphics[width=0.8\textwidth]{fig/quadtree_tree.png}
     \caption{Uma subdivisão feita por \textit{quadtree} com cinco níveis e sua representação em árvore.} 
     \label{fig:quadtree_tree}
 \end{figure}

\subsubsection{\textit{Octree}} 

A \textit{octree} é a versão tridimensional da \textit{quadtree}, por isso as mesmas propriedades da \textit{quadtree}se aplicam a ela (Figura \ref{fig:octree_tree}). A diferença é que a entrada será divida sempre em 8 partes com regiões de mesmo tamanho. Os cortes serão realizados nos eixos X, Y e Z.	


 \begin{figure}[htbp]
     \centering
     \includegraphics[width=0.8\textwidth]{fig/octree_tree.png}
     \caption{Uma subdivisão feita por \textit{octree} com três níveis e sua representação em árvore.} 
     \label{fig:octree_tree}
 \end{figure}

\subsubsection{\textit{Binary Space Partitioning} (BSP)}


BSP (particionamento binário espacial) é um processo genérico que, de forma recursiva, divide um domínio em duas partes, não necessariamente iguais, até que o particionamento do corte satisfaça um ou mais requisitos estabelecidos. Como resultado tem-se dois novos subespaços que podem ainda ser particionados recursivamente. O critério de posicionamento do corte e de parada no particionamento vai depender do objetivo que se deseja ao usar uma BSP. 

Pode-se dizer que a BSP é um caso genérico da \textit{quadtree}. A principal diferença entre elas basicamente é a quantidade de partições criadas (quatro para cada subdivisão na \textit{quadtree} e duas na BSP) e a desvantagem está na hora de encontrar o melhor corte para a BSP, que pode ser bastante custoso se comparado com a \textit{quadtree}.

 \begin{figure}[htbp]
     \centering
     \includegraphics[width=0.5\textwidth]{fig/ex_BSP.png}
     \caption{Uma subdivisão feita com BSP e sua representação em árvore.} 
     \label{fig:ex_BSP}
 \end{figure}



\subsection{Estimativa de Carga} 

Neste trabalho as estimativas de carga são classificadas entre três classes:

 \begin{enumerate}
	\item{Baseadas em estruturas de decomposição espacial.}
 	\item{Baseadas na quantidade de vértices/arestas/faces}
 	\item{Baseadas na área/volume.}
 \end{enumerate}

A primeira delas utiliza estruturas de decomposição espacial, tais como \textit{quadtrees}, \textit{octrees} e BSP's. A vantagem dessas estruturas é que o modelo de entrada é totalmente mapeado em uma estrutura de dados, podendo obter facilmente a informação precisa da quantidade de elementos em uma determinada região da entrada, em geral considera-se a quantidade células da estrutura de decomposição como a carga referente aquele modelo. As principais desvantagens destas estruturas são o tempo de criação e o espaço em memória necessário para guardar as informações.

A segunda estima a carga como sendo a quantidade de vértices,arestas ou faces presentes no modelo de entrada. Quanto maior essa quantidade, maior será a carga computacional necessária para aquele modelo de entrada. A principal desvantagem dessa abordagem é não ter como mensurar a carga que será necessária para realizar a computação interna ao modelo, tendo em vista que foi considerado apenas a quantidade de elementos no exterior do modelo, podendo assim gerar uma estimativa ruim para alguns casos.

A ultima classificação utiliza apenas informações geométricas para estima a carga, considerando assim que quanto maior a área ou volume, maior será a carga computacional necessária para o modelo de entrada. Essa abordagem é útil para modelos de entrada uniforme ou estruturado, porém, quando um modelo não uniforme ou não estruturado for dado como entrada, a estimativa poderá divergir bastante em relação carga a real.







\subsection{Particionamento de Malhas}
 
Na geração em paralelo de malhas é necessário dividir a entrada para realizar o processamento em paralelo das diversas partes. Existem duas formas de decompor o domínio, segundo  \cite{bib:Survey_Chrisochoides05}. Na primeira forma, uma malha grosseira da região é rapidamente gerada, sequencialmente, e dividida entre os processadores. Essa forma, chamada de decomposição discreta do domínio, envolve ainda o problema de particionamento da malha. 

A segunda forma de decompor o domínio envolve dividir a região a partir de funções, segmentos, eixos inerciais, ou estruturas auxiliares, por isso chamada de decomposição contínua do domínio. As regiões criadas serão compostas por parte do contorno de entrada juntamente com uma parte da região interna, criando assim subdomínios. Cada subdomínio é enviado a um processador, onde a malha será gerada.

Uma malha de interface é um conjunto de segmentos ou triângulos para o caso bidimensional ou, no caso tridimensional, um conjunto de triângulos ou tetraedros. Essa malha de interface faz a conexão entre duas partições vizinhas e faz o papel de uma nova fronteira. A forma que ela é criada vai depender da técnica que está sendo utilizada para particionar o domínio.

O particionamento contínuo pode ainda, ser subdividido em duas categorias, dependendo da forma como é gerada a malha entre os subdomínios, chamada de malha de interface. Se essa malha for gerada antes da malha interna ao subdomínio, essa abordagem é chamada de \textit{a priori}. Caso ela seja gerada depois, é chamada de \textit{a posteriori}. A geração da malha de interface \textit{a posteriori} geralmente requer sincronização entre processos. Uma vantagem da decomposição Contínua em relação a Discreta é que a entrada não é modificada. No trabalho de \cite{bib:deCougny99} apresenta esta classificação.
 
 
\subsection{Balanceamento de carga}
 
Neste trabalho é considerado a existência de duas categorias para o balanceamento de carga. A primeira irei chamar de abordagem Centralizada, para a utilização desta abordagem é necessário um processo responsável por manter todas as tarefas, os demais processos devem solicitar tarefas diretamente ao processo central.
 
A segunda abordagem é a Descentralizada, onde as tarefas estão divididas entre todos os processos disponíveis, a distribuição das tarefas em geral é feita logo no inicio do programa, podendo haver migração de tarefas para outros processos durante a execução.
 
As duas abordagens necessitam de uma boa estimativa de carga para se obter no final um bom balanceamento de carga entre os processos disponíveis. Técnicas que não possuem estimativa de carga em geral optam por escolher a estratégia Descentralizada. Nestes casos, para compensar a falta de estimativa, é criado muito mais tarefas que o número de processadores disponíveis, fazendo que implicitamente a carga em uma partição fique quase semelhante as outras.
 
A principal desvantagem da abordagem Centralizada é a quantidade de comunicações que são feitas ao processo central. Isto acaba gerando um gargalo devido a quantidade de requisições simultâneas que possam acontecer.
 
 
 
 
 
 
 
 
 
 
 
 


\section{Particionamento Baseado na Geometria}
\label{sec:decomposição_geometria}

O Trabalho de \cite{bib:VIDWANS94} apresenta uma técnica de particionamento Contínuo \textit{a priori} com balanceamento por divisão e conquista, onde pode ocorrer uma redistribuição das cargas dos processadores. Inicialmente os planos de corte são criados baseados na centroide, utilizando os eixos para orientação do plano de corte, podendo criar os cortes sempre em um dos eixos ou então alinhando o plano em relação a mais de um eixo. É criado então conjuntos de vértices, arestas e faces para cada subdomínio criado. Cada subdomínio é atribuído a um processador e são balanceados trocando elementos desses conjuntos com seus vizinhos. Figura \ref{fig:vidwans} mostra um exemplo de balanceamento de carga feito pelo método.


 \begin{figure}[htbp]
     \centering
     \includegraphics[width=0.5\textwidth]{fig/vidwans.png}
     \caption{Exemplo do método de divisão e conquistar de \cite{bib:VIDWANS94} para equilibrar a carga entre quatro processadores. (a) distribuição de carga inicial. (b) Distribuição de carga após o passo 1. (c) Distribuição de carga após o passo 2.}
     \label{fig:vidwans}
 \end{figure} 

 
No trabalho de \cite{bib:GAITHER96} traz uma técnica de geração de malha bidimensional por inserção de pontos com particionamento Discreto. A criação das partições é baseada na estimativa da área dos subdomínios e na área dos triângulos que estão sendo gerados, tentando criar assim regiões de áreas iguais. Inicialmente é gerada uma malha grosseira com os vértices de entrada e depois é realizado um agrupamento dos triângulos, de tal forma que ao final a quantidade de regiões e processadores sejam iguais. As novas fronteiras criadas são discretizadas e um algoritmo de Delaunay bidimensional é aplicado. A Figura \ref{fig:gaither} mostra o passo a passo da técnica.

 
 \begin{figure}[htbp]
     \centering
     \includegraphics[width=1.0\textwidth]{fig/gaither.png}
     \caption{Passo a passo da técnica de \cite{bib:GAITHER96}.}
     \label{fig:gaither}
 \end{figure} 

 
 Em \cite{bib:WU96}, uma técnica de particionamento Discreta é descrita. O particionamento é feito numa malha inicial grosseira. É identificado os subdomínios nesta malha grosseira com base na carga (área da região), no tamanho da interface e conectividade entre regiões. Após ter os subdomínios definidos, é feito um refinamento na malha inicial grosseira. Ao final os subdomínios são redefinidos com base na nova malha. A Figura \ref{fig:wu} ilustra o passo a passo da técnica. O trabalho de \cite{bib:BANK05} tem uma metodologia parecida, onde utiliza uma malha grosseira para realizar o particionamento, que é baseado na bisseção. 
 
 \begin{figure}[htbp]
     \centering
     \includegraphics[width=0.8\textwidth]{fig/wu.png}
     \caption{O passo a passo da técnica de \cite{bib:WU96}.}
     \label{fig:wu}
 \end{figure}  

 
Em \cite{bib:GALTIER96} permite utilizar duas abordagens Contínuas \textit{a priori} para particionamento. A primeira é pelo particionamento em um mesmo eixo pela distancia entre os planos de corte. A segunda é pelo particionamento recursivo onde os planos de cortes passam pelo momento de inércia. A malha das interfaces são criadas por um grafo de Voronoi, que por sua vez vem de uma triangulação de Delaunay dos vértices iniciais.
 

Em \cite{bib:SAID99} apresenta uma técnica de particionamento Discreta que utiliza uma grade volumétrica para auxiliar no particionamento. A estimativa de carga é realizada pela quantidade de faces presentes numa região. Tanto a malha quanto a grade volumétrica são geradas por Delaunay. As subdivisões são feitas considerando também o volume das regiões. A Figura \ref{fig:said} mostra um exemplo da formação dos subdomínios em


 \begin{figure}[htbp]
     \centering
     \includegraphics[width=0.9\textwidth]{fig/said.png}
     \caption{Exemplo da formação dos subdomínios em \cite{bib:SAID99}. Fronteira de entrada, grade auxiliar inicial e 6 subdomínios gerados juntamente com as suas discretizações respectivamente.}
     \label{fig:said}
 \end{figure} 


Em \cite{bib:Ivanov06}, foi desenvolvido um algoritmo com particionamento Contínuo \textit{a priori} baseado em Delaunay para geração de malhas tetraédricas em que o posicionamento do plano de corte é definido pelo centro de massa e pela matriz de inércia. O plano de corte é um plano perpendicular a um eixo que segue uma das três definições:

\begin{itemize}
  \item Planos criados são equidistantes;

  \item Volume entre os planos são iguais;

  \item Passa pelo centro de massa.
\end{itemize}

A escolha do critério utilizado para criar os subdomínios depende da geometria da entrada. Assim, dependendo da entrada, um critério pode ser melhor que outro, mas isso depende do conhecimento do usuário. Na Figura~\ref{fig:ivanov06}, as três formas de particionamento são apresentadas.

Após ter o plano de corte definido, é feita uma suavização da seção de corte e a sua triangulação por Delaunay para, posteriormente, serem geradas as malhas nos subdomínios. Um problema bem visível nesse método é que para se ter um bom plano de corte é preciso ter um modelo com uma geometria bem comportada, sem forma côncava, alongada ou afinada. Nesse trabalho a quantidade de subdomínios gerados é maior que a de processos para tentar melhorar o balanceamento dinâmico, uma vez que não se tem uma boa precisão na estimativa da carga.

 \begin{figure}[htbp]
     \centering
     \includegraphics[width=0.9\textwidth]{fig/ivanov06.jpg}
     \caption{As três formas de particionar. 1 - planos equidistantes. 2 - volume dos subdomínios iguais. 3 - centro de massa \cite{bib:Ivanov06}.}
     \label{fig:ivanov06}
 \end{figure}

Uma solução parecida é a apresentada em \cite{bib:Lammer00}, onde o plano de corte é traçado no centro de gravidade, porém em duas dimensões, ou seja, apenas um eixo de corte. Este eixo é usado para dividir o domínio recursivamente até que o número de subdomínios seja igual a quantidade de processadores. A partir do eixo, uma aresta é formada, e os valores nos seus pontos extremos são interpolados entre os valores dados como entrada. Uma malha de Delaunay é gerada em cada interior dos subdomínios.


\cite{bib:JURCZYK07} apresenta uma técnica de particionamento \textit{a priori} onde o plano de corte é criado segundo um série de requisitos. Entre os requisitos estão que o volume das regiões geradas devem ser aproximadamente a mesmo, o plano de corte deve ser mínimo, os seja, poucos elementos pertencem ao separador e o ângulo de junção com a fronteira de entrada não deve formar um ângulo agudo. O balanceamento desta técnica é feito pela quantidade de faces na superfície. A Figura \ref{fig:jurczyk} mostra o processo de particionamento.

 
 \begin{figure}[htbp]
     \centering
     \includegraphics[width=0.7\textwidth]{fig/jurczyk.png}
     \caption{Exemplo do processo de particionamento em \cite{bib:JURCZYK07}.}
     \label{fig:jurczyk}
 \end{figure} 


Em \cite{bib:ANDRA08}, é utilizado o centro de massa e o momento de inercia para encontrar os planos de corte do domínio. As interfaces são geradas \textit{a priori} por Delaunay bidimensional e convertidas depois para tridimensional. A Figura \ref{fig:andra} mostra um exemplo de particionamento feito pela técnica.

 \begin{figure}[htbp]
     \centering
     \includegraphics[width=0.6\textwidth]{fig/andra.png}
     \caption{Exemplo de um particionamento feito por \cite{bib:ANDRA08} para 8 subdomínios.}
     \label{fig:andra}
 \end{figure}


Em \cite{bib:Pirzadeh09}, é descrita uma técnica baseada em Avanço de Fronteiras e Avanço de Camadas com particionamento Contínuo \textit{a priori}.

Inicialmente, é gerada uma malha de superfície nos pontos dados como entrada. Logo em seguida, é feita uma estimativa de carga nos subdomínios utilizando uma \textit{octree} que usa a informação da quantidade de faces para subdividir o domínio. Se necessário, serão criados planos de partições que dividem o domínio em regiões com cargas aproximadamente iguais. As posições destes planos são definidas através do centro de densidade da malha. O centro de densidade indica onde a massa efetiva do sistema está concentrada.

Em seguida, são identificadas as faces que interceptam o plano de partição e uma malha parcial é gerada na região do plano de corte. Depois disso, para cada lado da partição são agrupadas as faces dos novos subdomínios. Esse processo é repetido até que um número máximo de subdivisões tenha ocorrido. Ao final da execução, tem que ser realizada uma junção de todas as submalhas. A Figura~\ref{fig:pirzadeh09} ilustra os principais passos dessa técnica para o caso bidimensional. Esta técnica gera malha por Avanço de Fronteira e é uma mistura de \textit{a priori} com \textit{a posteriori}, pois avança uma camada de elementos na interface para depois criar os subdomínios.

 \begin{figure}[htbp]
     \centering
     \includegraphics[width=0.8\textwidth]{fig/pirzadeh09.jpg}
     \caption{Os principais passos da técnica de \cite{bib:Pirzadeh09} para gerar os segmentos de interface.}
     \label{fig:pirzadeh09}
 \end{figure}
 
Como vantagem desta técnica Contínua pode-se citar que a utilização de avanço de camadas entre as partições faz com que a malha gerada seja praticamente idêntica a uma malha gerada sequencialmente, ou seja, não são gerados padrões entre as partições do domínio. Outra vantagem é que não é necessário nenhum pré-processamento custoso para definir ou construir as partições. Além disso, a construção da \textit{octree} para estimar a carga é automática e de baixo custo.

Uma das desvantagens desse método é que nem sempre é fácil gerar as malhas nas partições, especialmente em três dimensões. Além disso, a qualidade dessas malhas pode ser ruim, prejudicando assim a qualidade da malha gerada no modelo todo. Basear a quantidade de subdivisões num número máximo não é uma boa métrica para controlar a geração dos subdomínios quando não se tem uma boa estimativa de carga, isso pode gerar subdomínios em excesso, aumentando a comunicação entre os processos. 
 
 
Em \cite{bib:CHEN12} é apresentado uma técnica Contínua \textit{a priori} onde o plano de partição é posicionado usando o centro gravitacional juntamente como o eixo de inercia para dar a normal desse plano. Após isto é encontrado as arestas que fazem interseção com o plano de corte, eliminando aquelas que tenham vértices com vizinhança menor que dois, nas arestas restantes é realizado uma suavização (Figura \ref{fig:chen}). A interface é gerada pela execução de Delaunay nas arestas da fronteira encontrada. Apesar do esforço para a criação de uma boa interface, esta técnica não possui um estimativa de carga clara para os subdomínios, tentando compensar o balanceamento de carga fazendo \textit{over-decomposition} (criação de mais subdomínios que processadores disponíveis). Um trabalho parecido é \cite{bib:ZHENG09}, onde os planos de cortes devem ser os menores possíveis e que gerem subdomínios de tamanhos praticamente iguais. O posicionamento do corte no principal eixo de inércia.


 \begin{figure}[htbp]
     \centering
     \includegraphics[width=1.0\textwidth]{fig/chen.png}
     \caption{Da esquerda para direita: todas as arestas que sofrem interseção, a fronteira inicial, e a fronteira suavizada. Em \cite{bib:CHEN12}.}
     \label{fig:chen}
 \end{figure}
 
 
 Em \cite{bib:Glut08}, é apresentada uma técnica para malhas tridimensionais com uma abordagem baseada no particionamento geométrico onde a entrada é uma malha de superfície. Nesse trabalho são descritas duas técnicas baseadas na \textit{bounding box} gerada a partir da entrada.
 
 A seleção do separador do domínio deve garantir um custo de corte baixo, ou seja, encontrar e posicionar o plano de corte não pode ter um custo computacional alto. Além disso, deve garantir um bom balanceamento de carga e minimizar os elementos conectados por múltiplos subdomínios.
 
 A primeira técnica é baseada na malha de superfície. Para o plano de corte ser criado, é preciso a localização do contorno da malha de superfície e do separador. O contorno é então projetado no separador usando uma função 2D de controle espacial baseada no tamanho das arestas (Figura~\ref{fig:glut08_1}).
 
 \begin{figure}[htbp]
 	\centering
 	\includegraphics[width=0.8\textwidth]{fig/glut08_1.jpg}
 	\caption{Passos da técnica baseada na malha de superfície. (a) malha de superfície; (b) corte; (c) seção transversal; (d) malha final \cite{bib:Glut08}.}
 	\label{fig:glut08_1}
 \end{figure}
 
 A segunda técnica se baseia numa malha volumétrica grosseira. Primeiramente, é feita a geração de uma malha 3D grosseira utilizando alguma função de controle espacial. O posicionamento do plano de corte é feito parecido com a técnica anterior, porém utilizando a malha volumétrica como função espacial (Figura~\ref{fig:glut08_2}).
 
 \begin{figure}[!ht]
 	\centering
 	\includegraphics[width=0.8\textwidth]{fig/glut08_2.jpg}
 	\caption{Passos da técnica baseada na malha volumétrica grosseira. (a) malha volumétrica grosseira; (b) refinamento da seção transversal; (c) seção transversal; (d) malha final \cite{bib:Glut08}.}
 	\label{fig:glut08_2}
 \end{figure}
 
 
 Esta técnica depende muito da geometria da entrada já que são utilizadas informações da \textit{bounding box} dessa entrada. Isso afeta diretamente a criação dos planos de corte, e por consequência, a malha gerada ao final. Uma das motivações deste trabalho é evitar a criação de subdomínios baseados nos eixos de inércia, pois, segundo o próprio autor, os resultados não são bons.
 
 
 
\section{Particionamento Baseada em Estruturas de Dados} 
\label{sec:decomposição_est_dados}


Um dos primeiros trabalhos em particionamento de domínios foi o de \cite{bib:FARHAT88}, que desenvolveu uma técnica para particionamento de malhas quadrangulares de elementos finitos. Este trabalho subdivide um domínio de acordo com a quantidade de processadores disponíveis, esta técnica utiliza a própria estrutura da malha quadrangular de matriz/grade usando uma estrutura de grade que contém os elementos e realizando o particionamento e a estimativa de carga em cima desta matriz de elementos. A Figura \ref{fig:farhat} mostra um exemplo de particionamento.


\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.4\textwidth]{fig/farhat.png}
	\caption{Decomposição em 4 subdomínios de uma malha multiconectada na técnica de \cite{bib:FARHAT88}.}
	\label{fig:farhat}
\end{figure}


Alguns trabalhos como o de \cite{bib:BARNARD94} utilizam grafos para encontrar o corte no domínio. O corte é baseado num grafo criado com as arestas, maximizando a quantidade de vértices nos conjuntos e minimizando a quantidade de arestas cortadas pelo corte. A criação do grafo para o particionamento é ilustrada na Figura \ref{fig:barnard}. No trabalho de \cite{bib:SIMON91} além desta forma de particionamento, é mostrada também particionamentos feitos pela bisseção e pelo particionamento recursivo da bisseção espectral (autovetores da matriz Laplaciana de um grafo).


\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.8\textwidth]{fig/barnard.png}
   \caption{ Fluxograma da triangulação em paralelo \cite{bib:BARNARD94}.}
  \label{fig:barnard}
\end{figure}


Em \cite{bib:NIKISHKOV99}, um grafo é construído para fazer a estimativa de carga e para realizar o particionamento. O critério de subdivisão é a quantidade de elementos internos a cada subdomínio. A Figura \ref{fig:nikishkov} mostra um exemplo de particionamento para esta técnica.

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.9\textwidth]{fig/nikishkov.png}
   \caption{Oito subdomínios criados com quantidades iguais de elementos e do lado direito a otimização das partições em \cite{bib:NIKISHKOV99}. }
  \label{fig:nikishkov}
\end{figure}


Em \cite{bib:deCougny99}, a entrada do algoritmo é o contorno de um objeto. Cada processador fica com parte de uma \textit{octree} distribuída, que define planos de corte do domínio. A malha das células internas é gerada concorrentemente com \textit{templates}. A região entre o contorno e as células internas é preenchida por uma técnica de Avanço de Fronteira, onde são gerados os elementos internos a uma região delimitada pelos planos de corte. Por último é feita a conexão das malhas dos dois lados de cada plano e de suas intersecções. Essa técnica gera muitas partições, já que a cada subdivisão oito novos subdomínios são criados, e, por usar \textit{templates}, esta técnica pode gerar uma quantidade excessiva de elementos, além de possivelmente gerar elementos de qualidade ruim nas regiões próximas ao contorno.

Na técnica de \cite{bib:Lohner01}, é gerada uma \textit{octree} grosseira com relação ao contorno dado como entrada. Esta técnica é classificada como Contínua \textit{a posteriori}. Após essa geração, as células que contêm a parte da fronteira que gerará os menores elementos são identificadas. Assim, partes da malha, correspondentes a cada célula, são geradas simultaneamente por avanço de fronteira, de maneira que cada parte da malha gerada não possa cruzar as extremidades da célula que a contém. Cada octante sofre então um pequeno deslocamento na diagonal com o intuito de gerar mais elementos. Esse deslocamento elimina quase todas as faces entre duas ou mais células e diminui o tamanho da fronteira para o próximo passo. Desse modo a nova fronteira é encontrada e uma nova \textit{octree} é construída para ela, e o procedimento é repetido, até que não seja mais possível gerar malha. Na Figura \ref{fig:lohner}, são mostrados os passos do algoritmo e os deslocamentos que são realizados.


    \begin{figure}[!ht]
    \centering
    \subfloat[\textit{Octree} gerada para uma borda e passos do algoritmo (representação 2D, ou seja